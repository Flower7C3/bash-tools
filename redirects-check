#!/usr/bin/env bash

# URL redirects and status code checker
# Usage: ./redirects-check [OPTIONS] <data_file>

set -euo pipefail

# Main function wrapper
main() {
  # Check if common-functions exists
  if [[ ! -f "$(dirname "$0")/common-functions" ]]; then
    echo "Downloading common-functions from GitHub..."
    if ! curl -fsSL https://raw.githubusercontent.com/Flower7C3/bash-tools/master/common-functions -o "$(dirname "$0")/common-functions"; then
      echo "Failed to download common-functions"
      exit 1
    fi
  fi

  # Source common functions
  source "$(dirname "$0")/common-functions"

  # Call the actual main function
  redirects_main "$@"
}

redirects_main() {
  # Function to display usage
  function show_usage() {
    log_usage_title '[OPTIONS] <data_file>'
    echo
    echo 'Check URL redirects and status codes from a data file'
    echo
    log_header 'Options'
    log_usage_options_line '-t;--timeout <SECONDS>' \
      'Request timeout (default: %s)' "$DEFAULT_TIMEOUT"
    log_usage_options_line '-a;--user-agent <STRING>' \
      'User agent string (default: Mozilla/5.0...)'
    log_usage_options_line '-r;--max-redirects <NUM>' \
      'Maximum number of redirects to follow (default: %s)' "$DEFAULT_MAX_REDIRECTS"
    log_usage_options_line '-F;--format <FORMAT>' \
      'Output format: text, json, csv (default: text)'
    log_usage_options_line '-k;--insecure' \
      'Disable SSL certificate verification'
    log_usage_options_line '-u;--update' \
      'Update app'
    log_usage_options_line '-h;--help' \
      'Show this help message'
    echo
    log_header 'Data file format'
    echo '  Each line should contain three space-separated values:'
    echo -e "  $(styler text 'YELLOW')OLD_URL EXPECTED_CODE NEW_URL$(styler reset)"
    echo
    echo "  Example:"
    echo -e "  $(styler text 'YELLOW')https://example.com/old 301 https://example.com/new$(styler reset)"
    echo -e "  $(styler text 'YELLOW')https://test.com/page 302 https://test.com/redirect$(styler reset)"
    echo
    log_header 'Examples'
    log_usage_example_line 'redirects.txt'
    log_usage_example_line '-t 30 -v redirects.txt'
    log_usage_example_line '-F json -o results.json redirects.txt'
    log_usage_example_line '-p -P 10 redirects.txt'
    exit 0
  }

  # Default values
  DEFAULT_TIMEOUT=10
  DEFAULT_USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/20100101 Firefox/87.0"
  DEFAULT_MAX_REDIRECTS=5

  # Global variables
  TIMEOUT=$DEFAULT_TIMEOUT
  USER_AGENT="$DEFAULT_USER_AGENT"
  MAX_REDIRECTS=$DEFAULT_MAX_REDIRECTS
  OUTPUT_FORMAT="text"
  SSL_VERIFY=1
  DATA_FILE=""

  # Function to check redirect
  check_redirect() {
    local _old_url="$1"
    local _expected_code="$2"
    local _expected_url="$3"
    local _line_number="$4"

    # Build curl command
    local _curl_cmd="curl -s -i -k --max-time $TIMEOUT"

    # Add user agent
    _curl_cmd="$_curl_cmd -H 'User-Agent: $USER_AGENT'"

    # Add SSL verification
    if [[ "$SSL_VERIFY" == "0" ]]; then
      _curl_cmd="$_curl_cmd -k"
    fi

    # Add redirect handling
    _curl_cmd="$_curl_cmd --max-redirs $MAX_REDIRECTS"

    # Add output format
    _curl_cmd="$_curl_cmd -o /dev/null --write-out '%{http_code}|%{redirect_url}|%{time_total}|%{url_effective}'"

    # Execute curl command
    local _response
    if ! response=$(eval "$_curl_cmd '$_old_url'" 2>/dev/null); then
      log_error 'Failed to check URL: <u>%s</u>' "$_old_url"
      return 1
    fi

    # Parse response
    IFS='|' read -r _response_code _redirect_url _time_total _url_effective <<<"$response"

    # Check if redirect is correct
    local _is_correct=0
    local _status_message=""

    if [[ "$_response_code" == "$_expected_code" ]]; then
      if [[ "$_expected_code" -ge 300 && "$_expected_code" -lt 400 ]]; then
        # For redirect codes, check if the redirect URL matches
        if [[ "$_redirect_url" == "$_expected_url" ]]; then
          _is_correct=1
          _status_message="Redirect correct"
        else
          _status_message="Redirect URL mismatch: got '$_redirect_url', expected '$_expected_url'"
        fi
      else
        # For non-redirect codes, just check the code
        _is_correct=1
        _status_message="Status code correct"
      fi
    else
      _status_message="Status code mismatch: got '$_response_code', expected '$_expected_code'"
    fi

    # Output results based on format
    case "$OUTPUT_FORMAT" in
    "json")
      cat <<EOF
{
  "line_number": $_line_number,
  "old_url": "$_old_url",
  "expected_code": $_expected_code,
  "expected_url": "$_expected_url",
  "actual_code": $_response_code,
  "actual_url": "$_redirect_url",
  "final_url": "$_url_effective",
  "response_time": $_time_total,
  "is_correct": $_is_correct,
  "status": "$_status_message"
}
EOF
      ;;
    "csv")
      echo "$_line_number,$_old_url,$_expected_code,$_expected_url,$_response_code,$_redirect_url,$_url_effective,$_time_total,$_is_correct,\"$_status_message\""
      ;;
    *)
      # Text format
      printf "%-4d %-60s " "$_line_number" "$_old_url"
      if [[ $_is_correct -eq 1 ]]; then
        printf "$(styler text 'GREEN')✓ %s" "$_status_message"
      else
        printf "$(styler text 'RED')✗ %s" "$_status_message"
      fi
      printf "$(styler reset) (%ss)" "$_time_total"
      echo
      ;;
    esac

    # Log error to file if incorrect
    if [[ $_is_correct -eq 0 ]]; then
      echo "$_old_url	$_response_code	$_redirect_url" >>"${DATA_FILE}.error.log"
      return 1
    fi

    return 0
  }

  # Function to process data file
  process_data_file() {
    local _file="$1"

    if [[ ! -f "$_file" ]]; then
      log_error 'Data file not found: <u>%s</u>' "$_file"
      return 1
    fi

    log_info 'Processing redirects from file: <u>%s</u>' "$_file"

    # Create error log file
    rm -f "${_file}.error.log"
    touch "${_file}.error.log"

    # Add CSV header if output format is CSV
    if [[ "$OUTPUT_FORMAT" == "csv" ]]; then
      echo "Line,Old URL,Expected Code,Expected URL,Actual Code,Actual URL,Final URL,Response Time,Correct,Status"
    fi

    local _line_number=0
    local _correct_count=0
    local _total_count=0

    while read -r _line; do
      _line_number=$((_line_number + 1))

      # Skip empty lines and comments
      [[ -z "$_line" || "$_line" =~ ^[[:space:]]*# ]] && continue

      # Parse line: OLD_URL EXPECTED_CODE NEW_URL
      local _old_url _expected_code _expected_url
      read -r _old_url _expected_code _expected_url <<<"$_line"

      # Validate inputs
      if [[ -z "$_old_url" || -z "$_expected_code" || -z "$_expected_url" ]]; then
        log_warning 'Skipping malformed line %s: $%s' "$_line_number" "$_line"
        continue
      fi

      if ! validate_url "$_old_url"; then
        continue
      fi

      if ! validate_url "$_expected_url"; then
        continue
      fi

      if ! [[ "$_expected_code" =~ ^[0-9]+$ ]]; then
        log_warning 'Invalid expected code on line %s: %s' "$_line_number" "$_expected_code"
        continue
      fi

      # Check redirect
      if check_redirect "$_old_url" "$_expected_code" "$_expected_url" "$_line_number"; then
        _correct_count=$((_correct_count + 1))
      fi

      _total_count=$((_total_count + 1))

    done <"$_file"

    # Summary
    log_info 'Processed %s redirects: %s correct, %s incorrect' "$_total_count" "$_correct_count" "$((_total_count - _correct_count))"

    if [[ -s "${_file}.error.log" ]]; then
      log_warning 'Errors logged to: <u>%s</u>' "${_file}.error.log"
    fi
  }

  # Function to parse command line arguments
  parse_arguments() {
    while [[ $# -gt 0 ]]; do
      case "$1" in
      -t | --timeout)
        TIMEOUT="$2"
        if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || [[ "$TIMEOUT" -lt 1 ]]; then
          log_error 'Invalid timeout: %s' "$TIMEOUT"
          exit 1
        fi
        shift 2
        ;;
      -a | --user-agent)
        USER_AGENT="$2"
        shift 2
        ;;
      -r | --max-redirects)
        MAX_REDIRECTS="$2"
        if ! [[ "$MAX_REDIRECTS" =~ ^[0-9]+$ ]] || [[ "$MAX_REDIRECTS" -lt 0 ]]; then
          log_error 'Invalid max redirects: %d' "$MAX_REDIRECTS"
          exit 1
        fi
        shift 2
        ;;
      -F | --format)
        OUTPUT_FORMAT="$2"
        if [[ "$OUTPUT_FORMAT" != "text" && "$OUTPUT_FORMAT" != "json" && "$OUTPUT_FORMAT" != "csv" ]]; then
          log_error 'Invalid output format: %s' "$OUTPUT_FORMAT"
          exit 1
        fi
        shift 2
        ;;
      -k | --insecure)
        SSL_VERIFY=0
        shift
        ;;
      -h | --help)
        show_usage
        ;;
      -u | --update)
        update_application
        ;;
      -*)
        log_error 'Unknown option: <b>%s</b>' "$1"
        echo
        show_usage
        ;;
      *)
        if [[ -z "$DATA_FILE" ]]; then
          DATA_FILE="$1"
        else
          log_error 'Multiple data files specified'
          exit 1
        fi
        shift
        ;;
      esac
    done
  }

  log_title 'Redirects Checker'

  # Check if curl is available
  check_dependencies curl

  # Parse arguments
  parse_arguments "$@"

  # Validate input
  if [[ -z "$DATA_FILE" ]]; then
    log_error 'No data file specified'
    show_usage
  fi

  # Process data file
  process_data_file "$DATA_FILE"
}

# Run main function
main "$@"
